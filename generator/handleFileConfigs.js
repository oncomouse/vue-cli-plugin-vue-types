const yaml = require('js-yaml');
const {
  __,
  T,
  add,
  always,
  apply,
  compose,
  concat,
  cond,
  equals,
  evolve,
  findLastIndex,
  filter,
  gte,
  identity,
  ifElse,
  juxt,
  keys,
  length,
  map,
  match,
  nth,
  replace,
  slice,
  test,
  tryCatch,
} = require('ramda');

/**
 * Mutates the configuration object by add "plugin:vue-types/strongly-recommended" to the extend
 * prop.
 * @function
 * @name attachExtends
 * @param {Object} obj An object whose .extend prop will be mutated by having the desired plugin
 * concatenated at the end.
 */
const attachExtends = evolve({
  extends: concat(__, ['plugin:vue-types/strongly-recommended']),
});
/**
 * Load the YAML object into memory, extend it, write it back to a string.
 * @function
 * @param {string} str the YAML source string
 * @param {number|boolean} spaces the number of spaces to indent OR a command to use tabs, instead.
 */
const processYaml = (str, spaces) => compose(
  xs => yaml.safeDump(xs, { indent: spaces.length }),
  attachExtends,
  yaml.safeLoad,
)(str);
/**
 * Load the JSON object into memory, extend it, write it back to a string.
 * @function
 * @param {string} str the JSON source string
 * @param {number|boolean} spaces the number of spaces to indent OR a command to use tabs, instead.
 */
const processJSON = (str, spaces) => compose(
  x => JSON.stringify(x, null, spaces || '\t'),
  attachExtends,
  JSON.parse,
)(str);
/**
 * This function assembles arguments for a later str.replace call by collecting some
 * needed information into an array that will be then passed as arguments to the replacement
 * function.
 * @function
 * @name processJSFindSpacingAndInsertPoint
 * @param {string} ext JS extends key/prop pair containing an array of ESLint configurations.
 * @returns {Array} ext, spacing after a comma in the array, position in string to insert new code.
 */
const processJSFindSpacingAndInsertPoint = juxt([
  identity,
  compose(
    replace(',', ''),
    nth(0),
    match(/,\s+/),
  ),
  ifElse(
    compose(
      equals(1),
      length,
      nth(0),
      slice(-1, Infinity),
      match(/['"],{0,1}/g),
    ),
    compose(add(__, 1), findLastIndex(test(/['"]/))),
    findLastIndex(equals(',')),
  ),
]);
/**
 * The last three parameters are generated by {@link processJSFindSpacingAndInsertPoint}().
 * @function
 * @param {string} str The original JavaScript source.
 * @param {string} ex The extracted source code of extends key/value combo.
 * @param {string} spacing The whitespace after the comma in each entry in the extends prop.
 * @param {Number} insertPoint The position in str where we will insert the desired plugin.
 * @returns {string} Updated version of {@link str}.
 */
const processJSReplace = (str, ex, spacing, insertPoint) => replace(
  ex,
  `${ex.slice(0, insertPoint)},${spacing}'plugin:vue-types/strongly-recommended'${ex.slice(insertPoint)}`,
)(str);
/**
 * While cond() can sometimes be confusing, this version means we only have to call
 * the regular expression once, which is helpful for performance.
 *
 * This composition has two steps: first, it computes a match object. If that match object has a
 * length() >= 1, we find the spacing and insertion point, add str to that list and apply those as
 * arguments to the {@link processJSReplace} function.
 * @function
 * @param {string} str Source code for a JavaScript ESLint configuration.
 * @returns {string} If the configuration has a .extends prop, this is updated; otherwise, it just
 * returns {@link str}.
 */
const processJS = str => compose(
  cond([
    [
      compose(
        gte(__, 1),
        length,
      ),
      compose(
        apply(processJSReplace),
        concat([str]),
        processJSFindSpacingAndInsertPoint,
        nth(0),
      ),
    ],
    [T, always(str)],
  ]),
  match(new RegExp(/['"]{0,1}extends['"]{0,1}:\s{0,1}\[.*\]/, 'smi')),
)(str);
/**
 * @function
 * @name spaces
 * @param {string} str Multiline string to scan.
 * @return {Integer|Boolean} Either the number of spaces per indent OR false if tabs are used.
 */
const spaces = compose(
  ifElse(
    compose(equals(0), length), // Was there no match?
    always(false), // Return false
    compose(length, nth(0)), // Otherwise, return the first element of the match object
  ),
  match(/^ +/), // Get the first instance of an indentation
);
/**
* There is a large cond() call commented at the bottom of this file that checks
* file extensions, but just using this tryCatch block works just as well. We test first with
* JSON.parse and yaml.safeLoad, because they both throw errors when they have syntax problems,
* then we assume JavaScript, if the other two don't work.
*
* This tryCatch block has to be here, too, because it's how we load files named .eslintrc,
* which, according to the ESLint docs, can contain YAML, JSON, or JS.
 * @function
 * @param {string} file The relative path of the file being processed
 * @param {string} src The source of that file
 * @returns {string} The updated source of the file
 */
const handleFileConfig = src => tryCatch(
  () => processJSON(src, spaces(src)), // Try JSON.parse
  tryCatch( // Catch JSON error, call another tryCatch block
    () => processYaml(src, spaces(src)), // Try yaml.safeLoad
    () => processJS(src, spaces(src)), // Catch YAML error, assume JavaScript
  ),
)(src);

/**
 * @param {Object} tree Created by the @vue/cli GenerateAPI, this is an object whose keys are
 * relative file paths in our project and whose values are the source of those files. This parameter
 * is mutated in place by this function (ðŸ™„).
 */
const handleFileConfigs = tree => compose(
  map((file) => {
    // Process each file and update tree:
    tree[file] = handleFileConfig(tree[file]); // eslint-disable-line no-param-reassign
    return tree[file];
  }),
  filter(test(/^[^/]*eslintrc/)), // Only grab eslint config files in the root directory
  keys,
)(tree);

module.exports = { handleFileConfigs, attachExtends };

// This big test feels more efficient, but the above tryCatch code (which is the default anyway)
// actually works in all the tested situations, without the convoluted logic.
/* cond([
  // If the file name has slashes (ie. is not a root eslintrc), return undefined and remove later:
  [test(/\//), always(undefined)],
  // Test if the file is a .js file:
  [test(/\.js$/), () => processJS(src, spaces(src))],
  // Test if the file is a .json file:
  [test(/\.json$/), () => processJSON(src, spaces(src))],
  // Test if the file is a .yml or .yaml file:
  [test(/\.ya{0,1}ml/), () => processYaml(src, spaces(src))],
  // Otherwise, this lowkey nightmare of a tryCatch block:
  // If there is no file extension, we have to guess the syntax, which we accomplish by first
  // try-ing JSON.parse then try-ing yaml.safeLoad, which both throw errors if there are syntax
  // issues. If both error, we assume JavaScript.
  [T, tryCatch(
    () => processJSON(src, spaces(src)), // Try JSON.parse
    tryCatch( // Catch JSON error, call another tryCatch block
      () => processYaml(src, spaces(src)), // Try yaml.safeLoad
      () => processJS(src, spaces(src)), // Catch YAML error, assume JavaScript
    ),
  )],
]), */
